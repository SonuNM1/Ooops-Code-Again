# 🐳 Docker Learning Notes

## 📌 Introduction
- **Docker** is a platform for developing, shipping, and running applications inside containers.
- **Containers** package up an application and its dependencies, ensuring consistency across different environments.

---

## ❓ Why Docker? What Problem Does It Solve?
### ⚙️ Before Docker:
- 🏗️ Applications were deployed directly onto physical or virtual machines.
- 🧩 Each environment (development, testing, production) needed manual setup, leading to inconsistencies.
- ❌ "It works on my machine" was a common problem due to environment differences.
- ⚠️ Dependencies and libraries had to be installed manually on each machine.
- 📈 Scaling required setting up new servers and repeating configurations.

### 🚀 After Docker:
- 🏆 Applications run in isolated containers, ensuring consistency across all environments.
- 📦 Docker packages everything an application needs to run, including dependencies, into a single image.
- 🌐 Containers can run anywhere Docker is installed, eliminating environment-specific issues.
- 🔄 Simplifies deployment and scaling by enabling easy replication of containers.
- ⚡ Reduces the need for VM overhead, making deployments lightweight and faster.

---

## 🧠 Key Concepts
### 📸 Images:
- **Template/Blueprint** of the project or container.
- 📋 Contains the application code, dependencies, and runtime.
- 📌 Read-only, ready-to-use software package.
- 🏗️ Built with source codes, libraries, external dependencies, and tools.
- ✏️ Cannot be updated directly — create a new image to make changes.
- 🚫 Cannot run directly.

#### 📍 Image Examples:
- ⚙️ Node.js setup.
- ⚙️ React setup.
- 📄 Application code.
- 📦 Dependencies.
- 🛠️ Any other supporting tool.
- 📋 Dockerfile.

### 📦 Container:
- **Running instance** of an image.
- 🔧 Converts a project image into a running process.
- 🔐 Isolated from the host system — runs independently.

### 📜 Dockerfile:
- 📋 Script containing instructions to build a Docker image.

### 🌍 Docker Hub:
- 🏪 Public registry for Docker images.
- 📤 Allows pushing and pulling images.

### 💾 Volumes:
- 🗂️ Mechanism to persist data generated by and used by Docker containers.

---

## 💻 Basic Commands:
- 📝 `docker --version` : Check Docker version.
- 📥 `docker pull <image_name>` : Pull an image from Docker Hub.
- ▶️ `docker run <image_name>` : Run a container from an image.
- 📋 `docker ps` : List running containers.
- 📋 `docker ps -a` : List all containers.
- ⏹️ `docker stop <container_id>` : Stop a running container.
- 🗑️ `docker rm <container_id>` : Remove a container.
- 🗑️ `docker rmi <image_id>` : Remove an image.

---


## Docker Hub

- Docker Hub is a cloud-based service where you can store, share, and manage Docker images. 

    Think of it as GitHub for Docker Images. It allows you to pull pre-built images for popular software or push your custom images to share with others. 

### Pull Images (downloading)

- docker pull <image_name>

### Push Images (uploading)

- Tag your images 

    docker tag <local_image> <username>/<repo_name>

- Push the images

    docker push <username>/<repo_name>

### Search Images 

- docker search <image_name>

### Use Images in Projects

- Once an image is on Docker Hub, we can use it in any project by pulling it onto any machine with Docker installed. 

## 2 Types of Images: (Parent & Normal Image)

### Parent (Base) Image 

- A parent image is the starting point of our Docker image. It's the foundation upon which we build our custom image. 

- Purpose: Provides a pre-configured environment with essential tools or dependencies. 

### Normal (Child) Image 

- It is the custom image we create by adding our application code, dependencies, and configurations on top of a parent image. 

- Purpose: Packages our app along with everything it needs to run. 


## DockerFile 

- It is a text file that contains a set of instructions to build a Docker image. 

- Think of it as a recipe that Docker reads to create containers consistently. Each instruction in the Dockerfile tells Docker what to do, like installing dependencie, copying files, or setting environment variables. 

## Build & Run 

 - docker build -t basic-app .

    - This is the command to build the Docker image. 

    - docker build: tells docker to create a new image. 

    - -t basic-app: tags the image with the name basic-app 

    - .(dot) specifies the build context - the directory containing the Dockerfile and other project files 

## 🌐 Why Run a Local Node.js Project in Docker When It Already Works Without It? 

### 🚨 Before Docker 

- Environment Inconsistencies: 

    - Works only if our machine has the correct Node.js version, dependencies, and environment setup.

    - If someone else wants to run the project, they'd have to install Node.js, npm, and all dependencies manually. 

- Dependency Management: 

    - We're replying on our system's global Node.js and npm installations. 

    - Any system-wide update could break our project. 

- PORT Conflicts: 

    - If another service is already using port 5000, we'll run into conflicts. 

    - No easy way to isolate applications 

- Complex Setup for Collaboration: 

    - Sharing the project requires teammates to replicate our environment, which can lead to the infamours: "It works on my machine, but not on yours!"

### 🐳 After Docker (Running with Docker)

- Environment Consistency: 

    - Docker ensures everyone runs the exact same environment, regardless of the OS or machine.  

    - Our project runs with a Node.js version and dependencies frozen in the Docker version. 

- Easy Setup: 

    - No need to install Node.js or npm on the host machine - Docker handles it. 

    - Teammates only need Docker installed to run our project. 

- PORT Isolation: 

    - Containers have isolated networking. 

    - We can run multiple versions of the app side-by-side on different ports without interference. 

- Simplified Deployment: 

    - The same Docker image runs on any environment - local, staging, or production. 

    - Deployment becomes as simple as pushing the image to Docker Hub and pulling it from the server. 

### 🏆 In Short 

- Without Docker: Everyone sets up the project manually and risks environment inconsistencies. 

- With Docker: Our project is neatly packaged with everything it needs, ensuring consistency and simplicity across all machines. 