# ğŸ³ Docker Learning Notes

## ğŸ“Œ Introduction
- **Docker** is a platform for developing, shipping, and running applications inside containers.
- **Containers** package up an application and its dependencies, ensuring consistency across different environments.

---

## â“ Why Docker? What Problem Does It Solve?
### âš™ï¸ Before Docker:
- ğŸ—ï¸ Applications were deployed directly onto physical or virtual machines.
- ğŸ§© Each environment (development, testing, production) needed manual setup, leading to inconsistencies.
- âŒ "It works on my machine" was a common problem due to environment differences.
- âš ï¸ Dependencies and libraries had to be installed manually on each machine.
- ğŸ“ˆ Scaling required setting up new servers and repeating configurations.

### ğŸš€ After Docker:
- ğŸ† Applications run in isolated containers, ensuring consistency across all environments.
- ğŸ“¦ Docker packages everything an application needs to run, including dependencies, into a single image.
- ğŸŒ Containers can run anywhere Docker is installed, eliminating environment-specific issues.
- ğŸ”„ Simplifies deployment and scaling by enabling easy replication of containers.
- âš¡ Reduces the need for VM overhead, making deployments lightweight and faster.

---

## ğŸ§  Key Concepts
### ğŸ“¸ Images:
- **Template/Blueprint** of the project or container.
- ğŸ“‹ Contains the application code, dependencies, and runtime.
- ğŸ“Œ Read-only, ready-to-use software package.
- ğŸ—ï¸ Built with source codes, libraries, external dependencies, and tools.
- âœï¸ Cannot be updated directly â€” create a new image to make changes.
- ğŸš« Cannot run directly.

#### ğŸ“ Image Examples:
- âš™ï¸ Node.js setup.
- âš™ï¸ React setup.
- ğŸ“„ Application code.
- ğŸ“¦ Dependencies.
- ğŸ› ï¸ Any other supporting tool.
- ğŸ“‹ Dockerfile.

### ğŸ“¦ Container:
- **Running instance** of an image.
- ğŸ”§ Converts a project image into a running process.
- ğŸ” Isolated from the host system â€” runs independently.

### ğŸ“œ Dockerfile:
- ğŸ“‹ Script containing instructions to build a Docker image.

### ğŸŒ Docker Hub:
- ğŸª Public registry for Docker images.
- ğŸ“¤ Allows pushing and pulling images.

### ğŸ’¾ Volumes:
- ğŸ—‚ï¸ Mechanism to persist data generated by and used by Docker containers.

---

## ğŸ’» Basic Commands:
- ğŸ“ `docker --version` : Check Docker version.
- ğŸ“¥ `docker pull <image_name>` : Pull an image from Docker Hub.
- â–¶ï¸ `docker run <image_name>` : Run a container from an image.
- ğŸ“‹ `docker ps` : List running containers.
- ğŸ“‹ `docker ps -a` : List all containers.
- â¹ï¸ `docker stop <container_id>` : Stop a running container.
- ğŸ—‘ï¸ `docker rm <container_id>` : Remove a container.
- ğŸ—‘ï¸ `docker rmi <image_id>` : Remove an image.

---


## Docker Hub

- Docker Hub is a cloud-based service where you can store, share, and manage Docker images. 

    Think of it as GitHub for Docker Images. It allows you to pull pre-built images for popular software or push your custom images to share with others. 

### Pull Images (downloading)

- docker pull <image_name>

### Push Images (uploading)

- Tag your images 

    docker tag <local_image> <username>/<repo_name>

- Push the images

    docker push <username>/<repo_name>

### Search Images 

- docker search <image_name>

### Use Images in Projects

- Once an image is on Docker Hub, we can use it in any project by pulling it onto any machine with Docker installed. 

## 2 Types of Images: (Parent & Normal Image)

### Parent (Base) Image 

- A parent image is the starting point of our Docker image. It's the foundation upon which we build our custom image. 

- Purpose: Provides a pre-configured environment with essential tools or dependencies. 

### Normal (Child) Image 

- It is the custom image we create by adding our application code, dependencies, and configurations on top of a parent image. 

- Purpose: Packages our app along with everything it needs to run. 


## DockerFile 

- It is a text file that contains a set of instructions to build a Docker image. 

- Think of it as a recipe that Docker reads to create containers consistently. Each instruction in the Dockerfile tells Docker what to do, like installing dependencie, copying files, or setting environment variables. 

## Build & Run 

 - docker build -t basic-app .

    - This is the command to build the Docker image. 

    - docker build: tells docker to create a new image. 

    - -t basic-app: tags the image with the name basic-app 

    - .(dot) specifies the build context - the directory containing the Dockerfile and other project files 

## ğŸŒ Why Run a Local Node.js Project in Docker When It Already Works Without It? 

### ğŸš¨ Before Docker 

- Environment Inconsistencies: 

    - Works only if our machine has the correct Node.js version, dependencies, and environment setup.

    - If someone else wants to run the project, they'd have to install Node.js, npm, and all dependencies manually. 

- Dependency Management: 

    - We're replying on our system's global Node.js and npm installations. 

    - Any system-wide update could break our project. 

- PORT Conflicts: 

    - If another service is already using port 5000, we'll run into conflicts. 

    - No easy way to isolate applications 

- Complex Setup for Collaboration: 

    - Sharing the project requires teammates to replicate our environment, which can lead to the infamours: "It works on my machine, but not on yours!"

### ğŸ³ After Docker (Running with Docker)

- Environment Consistency: 

    - Docker ensures everyone runs the exact same environment, regardless of the OS or machine.  

    - Our project runs with a Node.js version and dependencies frozen in the Docker version. 

- Easy Setup: 

    - No need to install Node.js or npm on the host machine - Docker handles it. 

    - Teammates only need Docker installed to run our project. 

- PORT Isolation: 

    - Containers have isolated networking. 

    - We can run multiple versions of the app side-by-side on different ports without interference. 

- Simplified Deployment: 

    - The same Docker image runs on any environment - local, staging, or production. 

    - Deployment becomes as simple as pushing the image to Docker Hub and pulling it from the server. 

### ğŸ† In Short 

- Without Docker: Everyone sets up the project manually and risks environment inconsistencies. 

- With Docker: Our project is neatly packaged with everything it needs, ensuring consistency and simplicity across all machines. 