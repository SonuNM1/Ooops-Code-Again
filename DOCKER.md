# 🐳 Docker Learning Notes

## 📌 Introduction
- **Docker** is a platform for developing, shipping, and running applications inside containers.
- **Containers** package up an application and its dependencies, ensuring consistency across different environments.

---

## ❓ Why Docker? What Problem Does It Solve?
### ⚙️ Before Docker:
- 🏗️ Applications were deployed directly onto physical or virtual machines.
- 🧩 Each environment (development, testing, production) needed manual setup, leading to inconsistencies.
- ❌ "It works on my machine" was a common problem due to environment differences.
- ⚠️ Dependencies and libraries had to be installed manually on each machine.
- 📈 Scaling required setting up new servers and repeating configurations.

### 🚀 After Docker:
- 🏆 Applications run in isolated containers, ensuring consistency across all environments.
- 📦 Docker packages everything an application needs to run, including dependencies, into a single image.
- 🌐 Containers can run anywhere Docker is installed, eliminating environment-specific issues.
- 🔄 Simplifies deployment and scaling by enabling easy replication of containers.
- ⚡ Reduces the need for VM overhead, making deployments lightweight and faster.

---

## 🧠 Key Concepts
### 📸 Images:
- **Template/Blueprint** of the project or container.
- 📋 Contains the application code, dependencies, and runtime.
- 📌 Read-only, ready-to-use software package.
- 🏗️ Built with source codes, libraries, external dependencies, and tools.
- ✏️ Cannot be updated directly — create a new image to make changes.
- 🚫 Cannot run directly.

#### 📍 Image Examples:
- ⚙️ Node.js setup.
- ⚙️ React setup.
- 📄 Application code.
- 📦 Dependencies.
- 🛠️ Any other supporting tool.
- 📋 Dockerfile.

### 📦 Container:
- **Running instance** of an image.
- 🔧 Converts a project image into a running process.
- 🔐 Isolated from the host system — runs independently.

### 📜 Dockerfile:
- 📋 Script containing instructions to build a Docker image.

### 🌍 Docker Hub:
- 🏪 Public registry for Docker images.
- 📤 Allows pushing and pulling images.

### 💾 Volumes:
- 🗂️ Mechanism to persist data generated by and used by Docker containers.

---

## 💻 Basic Commands:
- 📝 `docker --version` : Check Docker version.
- 📥 `docker pull <image_name>` : Pull an image from Docker Hub.
- ▶️ `docker run <image_name>` : Run a container from an image.
- 📋 `docker ps` : List running containers.
- 📋 `docker ps -a` : List all containers.
- ⏹️ `docker stop <container_id>` : Stop a running container.
- 🗑️ `docker rm <container_id>` : Remove a container.
- 🗑️ `docker rmi <image_id>` : Remove an image.

---


## Docker Hub

- Docker Hub is a cloud-based service where you can store, share, and manage Docker images. 

    Think of it as GitHub for Docker Images. It allows you to pull pre-built images for popular software or push your custom images to share with others. 

### Pull Images (downloading)

- docker pull <image_name>

### Push Images (uploading)

- Tag your images 

    docker tag <local_image> <username>/<repo_name>

- Push the images

    docker push <username>/<repo_name>

### Search Images 

- docker search <image_name>

### Use Images in Projects

- Once an image is on Docker Hub, we can use it in any project by pulling it onto any machine with Docker installed. 

## 2 Types of Images: (Parent & Normal Image)

### Parent (Base) Image 

- A parent image is the starting point of our Docker image. It's the foundation upon which we build our custom image. 

- Purpose: Provides a pre-configured environment with essential tools or dependencies. 

### Normal (Child) Image 

- It is the custom image we create by adding our application code, dependencies, and configurations on top of a parent image. 

- Purpose: Packages our app along with everything it needs to run. 


## DockerFile 

- It is a text file that contains a set of instructions to build a Docker image. 

- Think of it as a recipe that Docker reads to create containers consistently. Each instruction in the Dockerfile tells Docker what to do, like installing dependencie, copying files, or setting environment variables. 

## Build & Run 

 - docker build -t basic-app .

    - This is the command to build the Docker image. 

    - docker build: tells docker to create a new image. 

    - -t basic-app: tags the image with the name basic-app 

    - .(dot) specifies the build context - the directory containing the Dockerfile and other project files 

## 🌐 Why Run a Local Node.js Project in Docker When It Already Works Without It? 

### 🚨 Before Docker 

- Environment Inconsistencies: 

    - Works only if our machine has the correct Node.js version, dependencies, and environment setup.

    - If someone else wants to run the project, they'd have to install Node.js, npm, and all dependencies manually. 

- Dependency Management: 

    - We're replying on our system's global Node.js and npm installations. 

    - Any system-wide update could break our project. 

- PORT Conflicts: 

    - If another service is already using port 5000, we'll run into conflicts. 

    - No easy way to isolate applications 

- Complex Setup for Collaboration: 

    - Sharing the project requires teammates to replicate our environment, which can lead to the infamours: "It works on my machine, but not on yours!"

### 🐳 After Docker (Running with Docker)

- Environment Consistency: 

    - Docker ensures everyone runs the exact same environment, regardless of the OS or machine.  

    - Our project runs with a Node.js version and dependencies frozen in the Docker version. 

- Easy Setup: 

    - No need to install Node.js or npm on the host machine - Docker handles it. 

    - Teammates only need Docker installed to run our project. 

- PORT Isolation: 

    - Containers have isolated networking. 

    - We can run multiple versions of the app side-by-side on different ports without interference. 

- Simplified Deployment: 

    - The same Docker image runs on any environment - local, staging, or production. 

    - Deployment becomes as simple as pushing the image to Docker Hub and pulling it from the server. 

### 🏆 In Short 

- Without Docker: Everyone sets up the project manually and risks environment inconsistencies. 

- With Docker: Our project is neatly packaged with everything it needs, ensuring consistency and simplicity across all machines. 

## .dockerignore 

A .dockerignore file is used to exclude files and directories from being copied into the Docker image when using the 'docker build' command. It works similarly to a .gitignore file in Git. 

- Reduces image size: Prevents unnecessary files (node_modules, logs, .env) from bloating the Docker image. 

- Improve Build Performance: Skips files that aren't needed, making the build process faster. 

- Enhance Security: Keeps sensitive files, like .env or credentials, out of the Docker image. 

## 🗑️ Delete Image and Container (With Docker Desktop and Terminal/CMD) : 

- **Remove Images:** removes a specific image by its name or ID

    docker image rm image_name

    docker image rm image_name -f

- **List Containers:** 

    docker ps -a 

- **Remove Containers:** 

    docker container rm container_name

    docker container rm container_name -f

- **Clean Up:** Deletes all unused data. Cleans everything not currently in use

    docker system prune -a

- **Build Images:** . means current directory 

    docker build -t image_name .

    docker build -t image_name:v2 .

        - Builds the image and assigns a version v2 to the image. 

- **Run Containers:** Runs a container from the 'basic-app:v2' image, names the container 'basic-app-container-v2' and maps port 5500 of our machine to port 5500 inside the container. 

    docker run -name basic-app-container-v2 -p 5500:5500 basic-app:v2

- docker image 

## Why Images Can't be Updated? 

- 🏗️ **Immutability Principle**

    - Once an image is created, it becomes a fixed snapshot of our application and its environment. 

    - This ensures that every time we create a container from the image, it starts in the same state - preventing unexpected changes. 

- 🔒 **Version Control and Traceability**:     

    - If images could be updated directly, it would be hard to track what changed and when. 

    - Docker forces us to create a new image for every change, making deployments more predictable and traceable. 

    - For every change, we have to make a new Image. 

- ⚙️ **Layered Architecture**: 

    - Docker uses a layered file-system. Each command in the 'Dockerfile' creates a new layer on top of the previous one. 

    - When we change the code, dependencies, or configuration, a new image is created by adding new layers instead of modifying existing ones. 

- 📦 **Container Consistency**: 

    - If we update an image directly, existing containers would become inconsistent, as they'd still be running the old version. 

 
## Docker Image Versioning and Management

**What is an Image Version?** 

    - In Docker, images are versioned using tags. 

    - A tag is a label used to differentiate versions of an image

    - docker build -t basic-app:v1.0 .

**Run a Container from a Specific Version**

- docker run -d -p 5000:5000 basic-app:v1.0

    This runs the container with version v1.0 and maps port 5000 of the host to 5000 of the container. 


## Volume in Docker

A Volume in Docker is used to persist data generated and used by Docker containers. By default, when a container stops or is removed, its data is gone. Volume solve this by creating a separate location outside the container's filesystem to store data. 

- Volume allows continuous changes to be reflected in real-time inside the running container. 

- Perfect for development environments where you're making frequent changes to files. 

- Create a named volume: 

    docker volume create app-data 

## Docker Compose File 

A Docker Compose file (docker-compose.yml) is used to define and run multi-container Docker applications. Instead of running multiple 'docker run' commands, we can manage everything in a single file. It simplifies starting, stopping, and managing and multiple containers at once. 

    - Define all services (containers) in one file. 

    - Easily manage networks, volumes, and dependencies. 

    - One command to start or stop everything 

    - docker compose up


## 🐳 Docker Hub 

- **docker login** 

- **Tag Image** 

    docker tag basic-app:latest sonumahto/basic-app:latest

- **Push Image** 

    docker push sonumahto/basic-app:latest

- **Pull Image**

    docker pull sonumahto/basic-app:latest


## How to make the app live on Docker? 

